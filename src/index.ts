import { ActionSchema, FIFOStrategy, MicroRollup } from "@stackr/stackr-js";
import bodyParser from "body-parser";
import express, { Request, Response } from "express";
import nodemailer from 'nodemailer';
import { stackrConfig } from "../stackr.config";
import { OTPRollup, otpSTF } from "./state";
import { StateMachine } from "@stackr/stackr-js/execution";
import  seedrandom from 'seedrandom';
import * as crypto from 'crypto';
import cors from 'cors';
import { ethers } from "ethers";
import { verifyTypedData } from 'viem'
import { domain,otpMock } from "./data";

// this file is generated by the deployment script
import * as genesisState from "../genesis-state.json";

// POST route to send email


const rollup = async () => {
  const counterFsm = new StateMachine({
    state: new OTPRollup(genesisState.state),
    stf: otpSTF,
  });

  const actionSchemaType = {
    type: "String",
    otp: "Number"
  };

  const otpInput = new ActionSchema("verify-otp", actionSchemaType);

  const buildStrategy = new FIFOStrategy();

  const { state, actions, events } = await MicroRollup({
    config: stackrConfig,
    useState: counterFsm,
    useAction: otpInput,
    useBuilder: { strategy: buildStrategy, autorun: true },
    useSyncer: { autorun: true },
  });

  // events.action.onEvent(ActionEvents.SUBMIT_ACTION, (action) => {
  //   console.log("action submitted", action);
  // });

  // events.batcher.onEvent(BatcherEvents.BATCH_ACTION, (batch) => {
  //   console.log("action batched", batch);
  // });

  // events.builder.onEvent(BuilderEvents.ORDER_BATCH, (batch) => {
  //   console.log("action batch ordered", batch);
  // });

  return { actions, state };
};

const app = express();
app.use(bodyParser.json());
const { actions, state } = await rollup();
app.use(cors());

// import { keccak256, toUtf8Bytes } from 'ethers/lib/utils';


  // Create a transporter using SMTP
  const transporter = nodemailer.createTransport({
      service: 'Gmail',
      auth: {
          user: 'adobeashu1812@gmail.com',
          pass: 'kjch wbxj frub scjm',
      },
  });

  // Define email options
  

  // Send email
  


  const addressEmailMap: { [address: string]: string } = {};

function generateOTP(seed: number, userAddress: string): number{
  const now = Date.now();
  const roundedTimestamp = Math.floor(now / (5 * 60 * 1000)); 
  console.log("A");
  let combinedData = seed + userAddress + Math.floor(roundedTimestamp).toString(); // Floor to the last 5 minutes

    // Hash the combined data to generate OTP
    // const otp = combinedData; // Take first 6 characters
    const encoder = new TextEncoder();
    const data = encoder.encode(combinedData);
    console.log("B");
    const buffer  = ethers.solidityPackedKeccak256(["bytes"],[data]).toString();

    combinedData = buffer.substring(0, 6);

  return parseInt(combinedData);
}

var email;
var userAddress = "0xFa00D29d378EDC57AA1006946F0fc6230a5E3288";

app.get("/", (req: Request, res: Response) => {
  const seed=696969;

  const otpDevice1 = generateOTP(seed,userAddress);
  console.log('OTP for Device 1:', otpDevice1);
  console.log(Date.now());
  res.send({ currentOtp: state.get().state.getState() });

});


app.post("/mail", async (req: Request, res: Response) => {
  email = req.body.email;
  userAddress = req.body.address;
  console.log(email,userAddress);
  const seed=1;
  const otpDevice1 = generateOTP(seed, userAddress);
  
  console.log('OTP for Device 1:', otpDevice1);

  const mailOptions: nodemailer.SendMailOptions = {
    from: 'adobeashu1812@gmail.com',
    to: email,
    subject: "OTP",
    text: otpDevice1.toString(),
};
  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
        console.error(error);
        res.status(500).send('Error sending email');
    } else {
        console.log('Email sent: ' + info.response);
        res.send('Email sent successfully');
    }
  });
  
});


app.post("/verify", async (req: Request, res: Response) => {
  const verifyRequest = req.body.signature;
  const data = req.body.payload;
  console.log(verifyRequest,data);
  const schema = actions.getSchema("verify-otp");
  const dataObject = {
    msgSender: userAddress,
    signature: verifyRequest,
    payload: data,
  };

  const payload = JSON.stringify(dataObject);


  if (!schema) {
    res.status(400).send({ message: "schema not found" });
    return;
  }
  
  try {
    const newAction = schema.newAction(dataObject);
    const ack = await actions.submit(newAction);
    res.status(201).send({ ack });
  } catch (e: any) {
    res.status(400).send( "yaha dhikkat h " + {error: e.message });
  }
  res.status(201).send({ data });
});


app.post("/", async (req: Request, res: Response) => {
  const schema = actions.getSchema("verify-otp");

  if (!schema) {
    res.status(400).send({ message: "error" });
    return;
  }
  


  const verifyRequest = JSON.parse(req.body.payload);
  // const valid = await verifyTypedData({
  //   address: "0xFa00D29d378EDC57AA1006946F0fc6230a5E3288",
  //   domain,
  //   types: otpMock,
  //   primaryType: 'verify-otp',
  //   message: verifyRequest.payload,
  //   signature: verifyRequest.signature,
  // })
  // console.log(valid);
  console.log(verifyRequest);
  try {
    // const signature = verifyRequest.signature;
    // ethers
    const newAction = schema.newAction(verifyRequest);
    const ack = await actions.submit(newAction);
    res.status(201).send({ ack });
  } catch (e: any) {
    res.status(400).send({ error: e.message });
  }
});

app.listen(3000, () => {
  console.log("listening on port 3000");
});

app.post("/addmail", async (req: Request, res: Response) => {
  console.log(req.body);
  const { userAddress, email } = req.body;
    addressEmailMap[userAddress.toLowerCase()] = email;
    res.status(200).send({ message: 'Email linked successfully' });
});

app.get('/get-email', (req, res) => {
  const ethAddress = req.query.ethAddress as string;
  const email = addressEmailMap[ethAddress.toLowerCase()];
  if (email) {
      const obscuredEmail = email.replace(/(.{3}).+(@.+?)(.{3}).*/, "$1***$2***");
      res.send({ email: obscuredEmail });
  } else {
      res.status(404).send({ message: 'Email not found' });
  }
});
// actionEventsEmitter.on(ActionEvents.SUBMIT_ACTION, (data) => {
//   console.log("submit_action - Event triggered : ", data.payload);
// });

// executorEventsEmitter.on(ExecutorEvents.EXECUTE_SINGLE, (data) => {
//   console.log("execute_single - Event triggered : ", data);
// });
